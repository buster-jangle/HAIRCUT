/*
  ___   _   _   ___   _   _ _____ ___   _   __
 / _ \ | \ | | / _ \ | \ | |_   _/ _ \ | | / /
/ /_\ \|  \| |/ /_\ \|  \| | | |/ /_\ \| |/ /
|  _  || . ` ||  _  || . ` | | ||  _  ||    \
| | | || |\  || | | || |\  | | || | | || |\  \
\_| |_/\_| \_/\_| |_/\_| \_/ \_/\_| |_/\_| \_/

Project $PROJECT_NAME main.cpp
Initial file automatically generated by PROGENY on 04/18/23 12:42:56
*/

#include "test.h" // include main header
#include "HAIRCUT.h" // include the default library

// include common headers by default
#include "stdio.h"
#include "stdlib.h"
#include <errno.h> // Error integer and strerror() function
#include <unistd.h> // write(), read(), close()
#include <fcntl.h> // Contains file controls like O_RDWR
#include <string>
#include <limits.h>
#include <chrono>
#include "stdbool.h"
#include <iostream>
#include <thread>
#include <mutex>
#include <plog/Log.h>
#include "plog/Initializers/RollingFileInitializer.h"
#include "math.h"
#ifdef MATPLOT
#include "matplotlibcpp.h"
#endif
using namespace std; // default namespace

#define SAMPLE_COUNT (1024*64)
f32_complex testDataset[SAMPLE_COUNT];

HAIRCUT pipeline;
HAIRCUT::resample interpolate;
HAIRCUT::callbackSink term;
void fail(){
    PLOG_ERROR << "Test Failed";
    exit(EXIT_FAILURE);
}

#ifdef MATPLOT
namespace plt = matplotlibcpp;
std::vector<float> graphInReal, graphInImag, graphOutReal, graphOutImag, xin, xout;
#endif

int totalOutputSamples = 0;
void getSamplesCallback(f32_complex* samples, int count){
    PLOGI.printf("Got samples callback");
    for(int i = 0; i < count; ++i){
       // PLOGD.printf("%i\tr:%f i:%f", i, samples[i].real, samples[i].imag);
#ifdef MATPLOT
        graphOutReal.push_back( (float)samples[i].real);
        graphOutImag.push_back( (float)samples[i].imag);
        totalOutputSamples += 1;
        xout.push_back(totalOutputSamples);
#endif
    }

}

int main(int argc, char *argv[]){

    static plog::RollingFileAppender<plog::CsvFormatter> fileAppender("test_block_fft.log", 1048576, 3); // Create the file appender, up to 1MB per file, rolling over 3 files
    static plog::ConsoleAppender<plog::TxtFormatter> consoleAppender; // Create the console appender
    plog::init(plog::debug,&fileAppender).addAppender(&consoleAppender); // Step2: initialize the logger

    PLOG_INFO << "Starting test.";

    for(int i = 0; i < SAMPLE_COUNT; ++i){
        float phase = (float)i * 1.0f;
        testDataset[i].real = sinf(phase);
        testDataset[i].imag = cosf(phase);
       // testDataset[i].real = ((rand() % 1024) - 512) / 512.0f;

        graphInReal.push_back((float)testDataset[i].real);
        graphInImag.push_back((float)testDataset[i].imag);
        xin.push_back(i);
    }
    bool testStatus = false;

    if(!pipeline.init(plog::get())){
        fail();
    }

    if(!interpolate.init(2048, 65536)){
        fail();
    }

    if(!term.init(&getSamplesCallback, 1024)){
        fail();
    }

    interpolate.outBuffer[0].connection.push_back(&term); // pipe data from interpolate to term

    /// Push in an oversized batch
    interpolate.push(testDataset, SAMPLE_COUNT);

//    /// push in randomly sized small batches
//    int i = 0;
//    while( i < SAMPLE_COUNT) {
//        interpolate.push(testDataset, rand() % 1024);
//        i += 9;
//    }

#ifdef MATPLOT

    // Set the size of output image to 1200x780 pixels
    plt::figure_size(1200, 780);
    // Plot line from given x and y data. Color is selected automatically.
    plt::plot(xin, graphInReal);
   /// plt::plot(xin, y);
    // Plot a red dashed line from given x and y data.
    plt::plot(xout, graphOutReal);
    // Plot a line whose name will show up as "log(x)" in the legend.
    //plt::named_plot("log(x)", x, z);
    // Set x-axis to interval [0,1000000]
    //plt::xlim(0, 1000*1000);
    // Add graph title
    plt::title("Sample figure");
    // Enable legend.
    plt::legend();
    // Display the plot
    plt::show();

#endif


    PLOG_INFO << "Test Passed";
    return EXIT_SUCCESS;
}